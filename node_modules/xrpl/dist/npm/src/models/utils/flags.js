"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransactionFlags = exports.setTransactionFlagsToNumber = exports.parseAccountRootFlags = void 0;
const errors_1 = require("../../errors");
const AccountRoot_1 = require("../ledger/AccountRoot");
const accountSet_1 = require("../transactions/accountSet");
const AMMDeposit_1 = require("../transactions/AMMDeposit");
const AMMWithdraw_1 = require("../transactions/AMMWithdraw");
const MPTokenAuthorize_1 = require("../transactions/MPTokenAuthorize");
const MPTokenIssuanceCreate_1 = require("../transactions/MPTokenIssuanceCreate");
const MPTokenIssuanceSet_1 = require("../transactions/MPTokenIssuanceSet");
const NFTokenCreateOffer_1 = require("../transactions/NFTokenCreateOffer");
const NFTokenMint_1 = require("../transactions/NFTokenMint");
const offerCreate_1 = require("../transactions/offerCreate");
const payment_1 = require("../transactions/payment");
const paymentChannelClaim_1 = require("../transactions/paymentChannelClaim");
const trustSet_1 = require("../transactions/trustSet");
const XChainModifyBridge_1 = require("../transactions/XChainModifyBridge");
const _1 = require(".");
function parseAccountRootFlags(flags) {
    const flagsInterface = {};
    Object.values(AccountRoot_1.AccountRootFlags).forEach((flag) => {
        if (typeof flag === 'string' &&
            (0, _1.isFlagEnabled)(flags, AccountRoot_1.AccountRootFlags[flag])) {
            flagsInterface[flag] = true;
        }
    });
    return flagsInterface;
}
exports.parseAccountRootFlags = parseAccountRootFlags;
const txToFlag = {
    AccountSet: accountSet_1.AccountSetTfFlags,
    AMMDeposit: AMMDeposit_1.AMMDepositFlags,
    AMMWithdraw: AMMWithdraw_1.AMMWithdrawFlags,
    MPTokenAuthorize: MPTokenAuthorize_1.MPTokenAuthorizeFlags,
    MPTokenIssuanceCreate: MPTokenIssuanceCreate_1.MPTokenIssuanceCreateFlags,
    MPTokenIssuanceSet: MPTokenIssuanceSet_1.MPTokenIssuanceSetFlags,
    NFTokenCreateOffer: NFTokenCreateOffer_1.NFTokenCreateOfferFlags,
    NFTokenMint: NFTokenMint_1.NFTokenMintFlags,
    OfferCreate: offerCreate_1.OfferCreateFlags,
    PaymentChannelClaim: paymentChannelClaim_1.PaymentChannelClaimFlags,
    Payment: payment_1.PaymentFlags,
    TrustSet: trustSet_1.TrustSetFlags,
    XChainModifyBridge: XChainModifyBridge_1.XChainModifyBridgeFlags,
};
function setTransactionFlagsToNumber(tx) {
    if (tx.Flags == null) {
        tx.Flags = 0;
        return;
    }
    if (typeof tx.Flags === 'number') {
        return;
    }
    tx.Flags = txToFlag[tx.TransactionType]
        ? convertFlagsToNumber(tx.Flags, txToFlag[tx.TransactionType])
        : 0;
}
exports.setTransactionFlagsToNumber = setTransactionFlagsToNumber;
function convertFlagsToNumber(flags, flagEnum) {
    return Object.keys(flags).reduce((resultFlags, flag) => {
        if (flagEnum[flag] == null) {
            throw new errors_1.ValidationError(`flag ${flag} doesn't exist in flagEnum: ${JSON.stringify(flagEnum)}`);
        }
        return flags[flag] ? resultFlags | flagEnum[flag] : resultFlags;
    }, 0);
}
function parseTransactionFlags(tx) {
    setTransactionFlagsToNumber(tx);
    if (typeof tx.Flags !== 'number' || !tx.Flags || tx.Flags === 0) {
        return {};
    }
    const flags = tx.Flags;
    const flagsMap = {};
    const flagEnum = txToFlag[tx.TransactionType];
    Object.values(flagEnum).forEach((flag) => {
        if (typeof flag === 'string' && (0, _1.isFlagEnabled)(flags, flagEnum[flag])) {
            flagsMap[flag] = true;
        }
    });
    return flagsMap;
}
exports.parseTransactionFlags = parseTransactionFlags;
//# sourceMappingURL=flags.js.map